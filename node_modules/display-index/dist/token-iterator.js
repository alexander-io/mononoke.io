'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _screenLineIterator = require('./screen-line-iterator');

var _screenLineIterator2 = _interopRequireDefault(_screenLineIterator);

var _pointHelpers = require('./point-helpers');

var ZERO_TOKEN = Object.freeze({
  screenStartOffset: 0,
  screenEndOffset: 0,
  bufferStartOffset: _pointHelpers.ZERO_POINT,
  bufferEndOffset: _pointHelpers.ZERO_POINT
});

var TokenIterator = (function () {
  function TokenIterator(displayIndex) {
    _classCallCheck(this, TokenIterator);

    this.displayIndex = displayIndex;
    this.lineIterator = new _screenLineIterator2['default'](displayIndex);
    this.clearCachedPositions();
  }

  _createClass(TokenIterator, [{
    key: 'seekToScreenPosition',
    value: function seekToScreenPosition(targetPosition) {
      this.clearCachedPositions();

      var clippedTargetPosition = targetPosition;
      if (clippedTargetPosition.row < 0) {
        clippedTargetPosition = _pointHelpers.ZERO_POINT;
      }
      if (clippedTargetPosition.column < 0) {
        clippedTargetPosition = { row: clippedTargetPosition.row, column: 0 };
      }
      var lastScreenRow = this.displayIndex.getLastScreenRow();
      if (clippedTargetPosition.row > lastScreenRow) {
        clippedTargetPosition = { row: lastScreenRow, column: Infinity };
      }

      this.lineIterator.seekToScreenRow(clippedTargetPosition.row);

      var tokens = this.lineIterator.getTokens();

      if (!tokens) {
        return false;
      }

      var targetColumn = clippedTargetPosition.column;
      var startIndex = 0;
      var endIndex = tokens.length;
      var token = undefined;

      while (startIndex < endIndex) {
        this.tokenIndex = Math.floor((startIndex + endIndex) / 2);
        token = tokens[this.tokenIndex];

        if (targetColumn <= token.screenStartOffset) {
          endIndex = this.tokenIndex;
        } else {
          if (targetColumn <= token.screenEndOffset) {
            break;
          } else {
            startIndex = this.tokenIndex + 1;
          }
        }
      }

      // if at start of a token, rewind in case there are empty tokens before it
      while (targetColumn === token.screenStartOffset && this.tokenIndex > 0) {
        this.tokenIndex--;
        token = tokens[this.tokenIndex];
      }

      // if at the end of a token, advance to beginning of next token unless
      // current token is empty
      if (targetColumn === token.screenEndOffset && token.screenExtent > 0 && this.tokenIndex < tokens.length - 1) {
        this.moveToSuccessor();
      }
    }
  }, {
    key: 'seekToBufferPosition',
    value: function seekToBufferPosition(targetPosition) {
      this.clearCachedPositions();

      var clippedTargetPosition = targetPosition;
      if (clippedTargetPosition.row < 0) {
        clippedTargetPosition = _pointHelpers.ZERO_POINT;
      }
      if (clippedTargetPosition.column < 0) {
        clippedTargetPosition = { row: clippedTargetPosition.row, column: 0 };
      }

      this.lineIterator.seekToBufferPosition(clippedTargetPosition);

      clippedTargetPosition = (0, _pointHelpers.minPoint)(clippedTargetPosition, this.lineIterator.getBufferEnd());

      var tokens = this.lineIterator.getTokens();

      if (!tokens) {
        return false;
      }

      var targetOffsetInLine = (0, _pointHelpers.traversalDistance)(clippedTargetPosition, this.lineIterator.getBufferStart());
      var startIndex = 0;
      var endIndex = tokens.length;
      var token = undefined;

      while (startIndex < endIndex) {
        this.tokenIndex = Math.floor((startIndex + endIndex) / 2);
        token = tokens[this.tokenIndex];

        if ((0, _pointHelpers.compare)(targetOffsetInLine, token.bufferStartOffset) <= 0) {
          endIndex = this.tokenIndex;
        } else {
          if ((0, _pointHelpers.compare)(targetOffsetInLine, token.bufferEndOffset) <= 0) {
            break;
          } else {
            startIndex = this.tokenIndex + 1;
          }
        }
      }

      // if at start of a token, rewind in case there are empty tokens before it
      while ((0, _pointHelpers.compare)(targetOffsetInLine, token.bufferStartOffset) === 0 && this.tokenIndex > 0) {
        this.tokenIndex--;
        token = tokens[this.tokenIndex];
      }

      // if at the end of a token, advance to beginning of next token unless
      // current token is empty
      if ((0, _pointHelpers.compare)(targetOffsetInLine, token.bufferEndOffset) === 0 && !(0, _pointHelpers.isZero)(token.bufferExtent) && this.tokenIndex < tokens.length - 1) {
        this.moveToSuccessor();
      }
    }
  }, {
    key: 'moveToSuccessor',
    value: function moveToSuccessor() {
      if (this.tokenIndex < this.lineIterator.getTokens().length - 1) {
        this.tokenIndex++;
      } else {
        if (this.lineIterator.moveToSuccessor()) {
          this.tokenIndex = 0;
        } else {
          return false;
        }
      }

      this.clearCachedPositions();
      return true;
    }
  }, {
    key: 'moveToPredecessor',
    value: function moveToPredecessor() {
      if (this.tokenIndex > 0) {
        this.tokenIndex--;
      } else {
        if (this.lineIterator.moveToPredecessor()) {
          this.tokenIndex = this.lineIterator.getTokens().length - 1;
        } else {
          return false;
        }
      }

      this.clearCachedPositions();
      return true;
    }
  }, {
    key: 'getScreenStart',
    value: function getScreenStart() {
      if (this.screenStart) return this.screenStart;

      var row = this.lineIterator.getScreenRow();
      var column = this.getCurrentToken().screenStartOffset;
      this.screenStart = { row: row, column: column };

      return this.screenStart;
    }
  }, {
    key: 'getScreenEnd',
    value: function getScreenEnd() {
      if (this.screenEnd) return this.screenEnd;

      var row = this.lineIterator.getScreenRow();
      var column = this.getCurrentToken().screenEndOffset;
      this.screenEnd = { row: row, column: column };

      return this.screenEnd;
    }
  }, {
    key: 'getScreenExtent',
    value: function getScreenExtent() {
      return this.getCurrentToken().screenExtent;
    }
  }, {
    key: 'getBufferStart',
    value: function getBufferStart() {
      if (this.bufferStart) return this.bufferStart;

      var lineStart = this.lineIterator.getBufferStart();
      var tokenStartOffset = this.getCurrentToken().bufferStartOffset;
      this.bufferStart = (0, _pointHelpers.traverse)(lineStart, tokenStartOffset);

      return this.bufferStart;
    }
  }, {
    key: 'getBufferEnd',
    value: function getBufferEnd() {
      if (this.bufferEnd) return this.bufferEnd;

      var lineStart = this.lineIterator.getBufferStart();
      var tokenStartOffset = this.getCurrentToken().bufferEndOffset;
      this.bufferEnd = (0, _pointHelpers.traverse)(lineStart, tokenStartOffset);

      return this.bufferEnd;
    }
  }, {
    key: 'getBufferExtent',
    value: function getBufferExtent() {
      return this.getCurrentToken().bufferExtent;
    }
  }, {
    key: 'getMetadata',
    value: function getMetadata() {
      return this.getCurrentToken().metadata;
    }
  }, {
    key: 'translateBufferPosition',
    value: function translateBufferPosition(bufferPosition) {
      if ((0, _pointHelpers.compare)(bufferPosition, this.getBufferStart()) < 0) {
        throw new Error('Position ' + (0, _pointHelpers.formatPoint)(bufferPosition) + ' is less than the current token\'s start (' + (0, _pointHelpers.formatPoint)(this.getBufferStart()) + ')');
      }

      return (0, _pointHelpers.minPoint)(this.getScreenEnd(), (0, _pointHelpers.traverse)(this.getScreenStart(), (0, _pointHelpers.traversalDistance)(bufferPosition, this.getBufferStart())));
    }
  }, {
    key: 'translateScreenPosition',
    value: function translateScreenPosition(screenPosition) {
      if ((0, _pointHelpers.compare)(screenPosition, this.getScreenStart()) < 0) {
        throw new Error('Position ' + (0, _pointHelpers.formatPoint)(screenPosition) + ' is less than the current token\'s start (' + (0, _pointHelpers.formatPoint)(this.getScreenStart()) + ')');
      }

      return (0, _pointHelpers.minPoint)(this.getBufferEnd(), (0, _pointHelpers.traverse)(this.getBufferStart(), (0, _pointHelpers.traversalDistance)(screenPosition, this.getScreenStart())));
    }
  }, {
    key: 'getCurrentToken',
    value: function getCurrentToken() {
      var tokens = this.lineIterator.getTokens();
      if (tokens && tokens.length > 0) {
        return this.lineIterator.getTokens()[this.tokenIndex];
      } else {
        return ZERO_TOKEN;
      }
    }
  }, {
    key: 'clearCachedPositions',
    value: function clearCachedPositions() {
      this.screenStart = null;
      this.screenEnd = null;
      this.bufferStart = null;
      this.bufferEnd = null;
    }
  }]);

  return TokenIterator;
})();

exports['default'] = TokenIterator;
module.exports = exports['default'];