'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _pointHelpers = require('./point-helpers');

var idCounter = 0;

var LineNode = (function () {
  function LineNode(_ref, left, right, priority) {
    var screenExtent = _ref.screenExtent;
    var bufferExtent = _ref.bufferExtent;
    var tokens = _ref.tokens;
    var softWrappedAtStart = _ref.softWrappedAtStart;
    var softWrappedAtEnd = _ref.softWrappedAtEnd;

    _classCallCheck(this, LineNode);

    this.screenExtent = screenExtent;
    this.bufferExtent = bufferExtent;
    this.tokens = tokens;
    this.softWrappedAtStart = softWrappedAtStart;
    this.softWrappedAtEnd = softWrappedAtEnd;
    this.left = left;
    this.right = right;
    this.priority = priority;
    this.id = ++idCounter;
    this.parent = null;

    this.computeTokenOffsets();
    this.computeSubtreeProperties();
  }

  _createClass(LineNode, [{
    key: 'computeTokenOffsets',
    value: function computeTokenOffsets() {
      var screenStartOffset = 0;
      var bufferStartOffset = _pointHelpers.ZERO_POINT;
      var tokenCount = this.tokens.length;

      if (tokenCount === 0) throw new Error('Lines must contain at least one token');

      for (var i = 0; i < tokenCount; i++) {
        var token = this.tokens[i];
        var screenEndOffset = screenStartOffset + token.screenExtent;
        var bufferEndOffset = (0, _pointHelpers.traverse)(bufferStartOffset, token.bufferExtent);
        token.screenStartOffset = screenStartOffset;
        token.screenEndOffset = screenEndOffset;
        token.bufferStartOffset = bufferStartOffset;
        token.bufferEndOffset = bufferEndOffset;
        screenStartOffset = screenEndOffset;
        bufferStartOffset = bufferEndOffset;
      }
    }
  }, {
    key: 'computeSubtreeProperties',
    value: function computeSubtreeProperties() {
      var leftSubtreeRowCount = this.left ? this.left.subtreeRowCount : 0;
      var rightSubtreeRowCount = this.right ? this.right.subtreeRowCount : 0;
      this.subtreeRowCount = leftSubtreeRowCount + 1 + rightSubtreeRowCount;

      var leftMax = this.left ? this.left.maxScreenExtent : -1;
      var rightMax = this.right ? this.right.maxScreenExtent : -1;
      this.maxScreenExtent = Math.max(leftMax, this.screenExtent, rightMax);

      var leftSubtreeBufferExtent = this.left ? this.left.subtreeBufferExtent : _pointHelpers.ZERO_POINT;
      var rightSubtreeBufferExtent = this.right ? this.right.subtreeBufferExtent : _pointHelpers.ZERO_POINT;
      this.subtreeBufferExtent = (0, _pointHelpers.traverse)((0, _pointHelpers.traverse)(leftSubtreeBufferExtent, this.bufferExtent), rightSubtreeBufferExtent);
    }
  }, {
    key: 'getLeftSubtreeRowCount',
    value: function getLeftSubtreeRowCount() {
      if (this.left) {
        return this.left.subtreeRowCount;
      } else {
        return 0;
      }
    }
  }, {
    key: 'getLeftSubtreeBufferExtent',
    value: function getLeftSubtreeBufferExtent() {
      if (this.left) {
        return this.left.subtreeBufferExtent;
      } else {
        return _pointHelpers.ZERO_POINT;
      }
    }
  }, {
    key: 'appendScreenLines',
    value: function appendScreenLines(tokenLines) {
      if (this.left) {
        this.left.appendScreenLines(tokenLines);
      }
      tokenLines.push({
        screenExtent: this.screenExtent,
        bufferExtent: this.bufferExtent,
        tokens: this.tokens,
        softWrappedAtStart: this.softWrappedAtStart,
        softWrappedAtEnd: this.softWrappedAtEnd
      });
      if (this.right) {
        this.right.appendScreenLines(tokenLines);
      }
    }
  }]);

  return LineNode;
})();

exports['default'] = LineNode;
module.exports = exports['default'];