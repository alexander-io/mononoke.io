'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var _helpers = require('./helpers');

var _pointHelpers = require('./point-helpers');

var Iterator = (function () {
  function Iterator(markerIndex) {
    _classCallCheck(this, Iterator);

    this.markerIndex = markerIndex;
  }

  _createClass(Iterator, [{
    key: 'reset',
    value: function reset() {
      this.node = this.markerIndex.root;
      this.nodeOffset = this.node ? this.node.leftExtent : null;
      this.leftAncestorOffset = { row: 0, column: 0 };
      this.rightAncestorOffset = { row: Infinity, column: Infinity };
      this.leftAncestorOffsetStack = [];
      this.rightAncestorOffsetStack = [];
    }
  }, {
    key: 'insertMarkerStart',
    value: function insertMarkerStart(markerId, startOffset, endOffset) {
      this.reset();

      if (!this.node) {
        var node = new _node2['default'](null, startOffset);
        this.markerIndex.root = node;
        return node;
      }

      while (true) {
        var comparison = (0, _pointHelpers.compare)(startOffset, this.nodeOffset);
        if (comparison === 0) {
          this.markRight(markerId, startOffset, endOffset);
          return this.node;
        } else if (comparison < 0) {
          this.markRight(markerId, startOffset, endOffset);
          if (this.node.left) {
            this.descendLeft();
          } else {
            this.insertLeftChild(startOffset);
            this.descendLeft();
            this.markRight(markerId, startOffset, endOffset);
            return this.node;
          }
        } else {
          // startOffset > this.nodeOffset
          if (this.node.right) {
            this.descendRight();
          } else {
            this.insertRightChild(startOffset);
            this.descendRight();
            this.markRight(markerId, startOffset, endOffset);
            return this.node;
          }
        }
      }
    }
  }, {
    key: 'insertMarkerEnd',
    value: function insertMarkerEnd(markerId, startOffset, endOffset) {
      this.reset();

      if (!this.node) {
        var node = new _node2['default'](null, endOffset);
        this.markerIndex.root = node;
        return node;
      }

      while (true) {
        var comparison = (0, _pointHelpers.compare)(endOffset, this.nodeOffset);
        if (comparison === 0) {
          this.markLeft(markerId, startOffset, endOffset);
          return this.node;
        } else if (comparison < 0) {
          if (this.node.left) {
            this.descendLeft();
          } else {
            this.insertLeftChild(endOffset);
            this.descendLeft();
            this.markLeft(markerId, startOffset, endOffset);
            return this.node;
          }
        } else {
          // endOffset > this.nodeOffset
          this.markLeft(markerId, startOffset, endOffset);
          if (this.node.right) {
            this.descendRight();
          } else {
            this.insertRightChild(endOffset);
            this.descendRight();
            this.markLeft(markerId, startOffset, endOffset);
            return this.node;
          }
        }
      }
    }
  }, {
    key: 'insertSpliceBoundary',
    value: function insertSpliceBoundary(offset, isInsertionEnd) {
      this.reset();

      while (true) {
        var comparison = (0, _pointHelpers.compare)(offset, this.nodeOffset);
        if (comparison === 0 && !isInsertionEnd) {
          return this.node;
        } else if (comparison < 0) {
          if (this.node.left) {
            this.descendLeft();
          } else {
            this.insertLeftChild(offset);
            return this.node.left;
          }
        } else {
          // endOffset > this.nodeOffset
          if (this.node.right) {
            this.descendRight();
          } else {
            this.insertRightChild(offset);
            return this.node.right;
          }
        }
      }
    }
  }, {
    key: 'findIntersecting',
    value: function findIntersecting(start, end, resultSet) {
      this.reset();
      if (!this.node) return;

      while (true) {
        if ((0, _pointHelpers.compare)(start, this.nodeOffset) < 0) {
          if (this.node.left) {
            this.checkIntersection(start, end, resultSet);
            this.descendLeft();
          } else {
            break;
          }
        } else {
          if (this.node.right) {
            this.checkIntersection(start, end, resultSet);
            this.descendRight();
          } else {
            break;
          }
        }
      }

      do {
        this.checkIntersection(start, end, resultSet);
        this.moveToSuccessor();
      } while (this.node && (0, _pointHelpers.compare)(this.nodeOffset, end) <= 0);
    }
  }, {
    key: 'findContaining',
    value: function findContaining(offset, resultSet) {
      this.reset();
      if (!this.node) return;

      while (true) {
        this.checkIntersection(offset, offset, resultSet);

        if ((0, _pointHelpers.compare)(offset, this.nodeOffset) < 0) {
          if (this.node.left) {
            this.descendLeft();
          } else {
            break;
          }
        } else {
          if (this.node.right) {
            this.descendRight();
          } else {
            break;
          }
        }
      }
    }
  }, {
    key: 'findContainedIn',
    value: function findContainedIn(start, end, resultSet) {
      this.reset();
      if (!this.node) return;

      this.seekToFirstNodeGreaterThanOrEqualTo(start);

      var started = new Set();
      while (this.node && (0, _pointHelpers.compare)(this.nodeOffset, end) <= 0) {
        (0, _helpers.addToSet)(started, this.node.startMarkerIds);
        this.node.endMarkerIds.forEach(function (markerId) {
          if (started.has(markerId)) {
            resultSet.add(markerId);
          }
        });
        this.moveToSuccessor();
      }
    }
  }, {
    key: 'findStartingIn',
    value: function findStartingIn(start, end, resultSet) {
      this.reset();
      if (!this.node) return;

      this.seekToFirstNodeGreaterThanOrEqualTo(start);

      while (this.node && (0, _pointHelpers.compare)(this.nodeOffset, end) <= 0) {
        (0, _helpers.addToSet)(resultSet, this.node.startMarkerIds);
        this.moveToSuccessor();
      }
    }
  }, {
    key: 'findEndingIn',
    value: function findEndingIn(start, end, resultSet) {
      this.reset();
      if (!this.node) return;

      this.seekToFirstNodeGreaterThanOrEqualTo(start);

      while (this.node && (0, _pointHelpers.compare)(this.nodeOffset, end) <= 0) {
        (0, _helpers.addToSet)(resultSet, this.node.endMarkerIds);
        this.moveToSuccessor();
      }
    }
  }, {
    key: 'dump',
    value: function dump(filterSet) {
      var _this = this;

      this.reset();

      while (this.node && this.node.left) this.descendLeft();

      var snapshot = {};

      while (this.node) {
        this.node.startMarkerIds.forEach(function (markerId) {
          if (!filterSet || filterSet.has(markerId)) {
            snapshot[markerId] = { start: _this.nodeOffset, end: null };
          }
        });

        this.node.endMarkerIds.forEach(function (markerId) {
          if (!filterSet || filterSet.has(markerId)) {
            snapshot[markerId].end = _this.nodeOffset;
          }
        });

        this.moveToSuccessor();
      }

      return snapshot;
    }
  }, {
    key: 'seekToFirstNodeGreaterThanOrEqualTo',
    value: function seekToFirstNodeGreaterThanOrEqualTo(offset) {
      while (true) {
        var comparison = (0, _pointHelpers.compare)(offset, this.nodeOffset);

        if (comparison === 0) {
          break;
        } else if (comparison < 0) {
          if (this.node.left) {
            this.descendLeft();
          } else {
            break;
          }
        } else {
          if (this.node.right) {
            this.descendRight();
          } else {
            break;
          }
        }
      }

      if ((0, _pointHelpers.compare)(this.nodeOffset, offset) < 0) this.moveToSuccessor();
    }
  }, {
    key: 'markLeft',
    value: function markLeft(markerId, startOffset, endOffset) {
      if (!(0, _pointHelpers.isZero)(this.nodeOffset) && (0, _pointHelpers.compare)(startOffset, this.leftAncestorOffset) <= 0 && (0, _pointHelpers.compare)(this.nodeOffset, endOffset) <= 0) {
        this.node.leftMarkerIds.add(markerId);
      }
    }
  }, {
    key: 'markRight',
    value: function markRight(markerId, startOffset, endOffset) {
      if ((0, _pointHelpers.compare)(this.leftAncestorOffset, startOffset) < 0 && (0, _pointHelpers.compare)(startOffset, this.nodeOffset) <= 0 && (0, _pointHelpers.compare)(this.rightAncestorOffset, endOffset) <= 0) {
        this.node.rightMarkerIds.add(markerId);
      }
    }
  }, {
    key: 'ascend',
    value: function ascend() {
      if (this.node.parent) {
        if (this.node.parent.left === this.node) {
          this.nodeOffset = this.rightAncestorOffset;
        } else {
          this.nodeOffset = this.leftAncestorOffset;
        }
        this.leftAncestorOffset = this.leftAncestorOffsetStack.pop();
        this.rightAncestorOffset = this.rightAncestorOffsetStack.pop();
        this.node = this.node.parent;
        this.nodeOffset = (0, _pointHelpers.traverse)(this.leftAncestorOffset, this.node.leftExtent);
      } else {
        this.node = null;
        this.nodeOffset = null;
        this.leftAncestorOffset = { row: 0, column: 0 };
        this.rightAncestorOffset = { row: Infinity, column: Infinity };
      }
    }
  }, {
    key: 'descendLeft',
    value: function descendLeft() {
      this.leftAncestorOffsetStack.push(this.leftAncestorOffset);
      this.rightAncestorOffsetStack.push(this.rightAncestorOffset);

      this.rightAncestorOffset = this.nodeOffset;
      this.node = this.node.left;
      this.nodeOffset = (0, _pointHelpers.traverse)(this.leftAncestorOffset, this.node.leftExtent);
    }
  }, {
    key: 'descendRight',
    value: function descendRight() {
      this.leftAncestorOffsetStack.push(this.leftAncestorOffset);
      this.rightAncestorOffsetStack.push(this.rightAncestorOffset);

      this.leftAncestorOffset = this.nodeOffset;
      this.node = this.node.right;
      this.nodeOffset = (0, _pointHelpers.traverse)(this.leftAncestorOffset, this.node.leftExtent);
    }
  }, {
    key: 'moveToSuccessor',
    value: function moveToSuccessor() {
      if (!this.node) return;

      if (this.node.right) {
        this.descendRight();
        while (this.node.left) {
          this.descendLeft();
        }
      } else {
        while (this.node.parent && this.node.parent.right === this.node) {
          this.ascend();
        }
        this.ascend();
      }
    }
  }, {
    key: 'insertLeftChild',
    value: function insertLeftChild(offset) {
      this.node.left = new _node2['default'](this.node, (0, _pointHelpers.traversal)(offset, this.leftAncestorOffset));
    }
  }, {
    key: 'insertRightChild',
    value: function insertRightChild(offset) {
      this.node.right = new _node2['default'](this.node, (0, _pointHelpers.traversal)(offset, this.nodeOffset));
    }
  }, {
    key: 'checkIntersection',
    value: function checkIntersection(start, end, resultSet) {
      if ((0, _pointHelpers.compare)(this.leftAncestorOffset, end) <= 0 && (0, _pointHelpers.compare)(start, this.nodeOffset) <= 0) {
        (0, _helpers.addToSet)(resultSet, this.node.leftMarkerIds);
      }

      if ((0, _pointHelpers.compare)(start, this.nodeOffset) <= 0 && (0, _pointHelpers.compare)(this.nodeOffset, end) <= 0) {
        (0, _helpers.addToSet)(resultSet, this.node.startMarkerIds);
        (0, _helpers.addToSet)(resultSet, this.node.endMarkerIds);
      }

      if ((0, _pointHelpers.compare)(this.nodeOffset, end) <= 0 && (0, _pointHelpers.compare)(start, this.rightAncestorOffset) <= 0) {
        (0, _helpers.addToSet)(resultSet, this.node.rightMarkerIds);
      }
    }
  }]);

  return Iterator;
})();

exports['default'] = Iterator;
module.exports = exports['default'];