'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _randomSeed = require('random-seed');

var _randomSeed2 = _interopRequireDefault(_randomSeed);

var _iterator = require('./iterator');

var _iterator2 = _interopRequireDefault(_iterator);

var _node = require('./node');

var _node2 = _interopRequireDefault(_node);

var LineLengthIndex = (function () {
  function LineLengthIndex() {
    var seed = arguments.length <= 0 || arguments[0] === undefined ? Date.now() : arguments[0];

    _classCallCheck(this, LineLengthIndex);

    this.randomGenerator = new _randomSeed2['default'](seed);
    this.root = null;
    this.iterator = this.buildIterator();
  }

  _createClass(LineLengthIndex, [{
    key: 'buildIterator',
    value: function buildIterator() {
      return new _iterator2['default'](this);
    }
  }, {
    key: 'splice',
    value: function splice(start, oldExtent, newLineLengths) {
      var startNode = this.iterator.findNode(start - 1);
      var endNode = this.iterator.findNode(start + oldExtent);

      if (startNode) {
        startNode.priority = -1;
        this.bubbleNodeUp(startNode);
      }

      if (endNode) {
        endNode.priority = -2;
        this.bubbleNodeUp(endNode);
      }

      var newLineLengthsSubtree = this.treeFromLineLengths(newLineLengths);
      if (startNode) {
        startNode.right = newLineLengthsSubtree;
        if (newLineLengthsSubtree) newLineLengthsSubtree.parent = startNode;
        startNode.computeSubtreeProperties();
      } else if (endNode) {
        endNode.left = newLineLengthsSubtree;
        if (newLineLengthsSubtree) newLineLengthsSubtree.parent = endNode;
      } else {
        this.root = newLineLengthsSubtree;
      }

      if (endNode) endNode.computeSubtreeProperties();

      if (startNode) {
        startNode.priority = this.generateRandom();
        this.bubbleNodeDown(startNode);
      }

      if (endNode) {
        endNode.priority = this.generateRandom();
        this.bubbleNodeDown(endNode);
      }
    }
  }, {
    key: 'lineLengthForRow',
    value: function lineLengthForRow(row) {
      var node = this.iterator.findNode(row);
      if (node) {
        return node.lineLength;
      } else {
        return null;
      }
    }
  }, {
    key: 'getPointWithMaxLineLength',
    value: function getPointWithMaxLineLength() {
      return this.iterator.getPointWithMaxLineLength();
    }
  }, {
    key: 'bubbleNodeUp',
    value: function bubbleNodeUp(node) {
      while (node.parent && node.priority < node.parent.priority) {
        if (node === node.parent.left) {
          this.rotateNodeRight(node);
        } else {
          this.rotateNodeLeft(node);
        }
      }
    }
  }, {
    key: 'bubbleNodeDown',
    value: function bubbleNodeDown(node) {
      while (true) {
        var leftChildPriority = node.left ? node.left.priority : Infinity;
        var rightChildPriority = node.right ? node.right.priority : Infinity;

        if (leftChildPriority < rightChildPriority && leftChildPriority < node.priority) {
          this.rotateNodeRight(node.left);
        } else if (rightChildPriority < node.priority) {
          this.rotateNodeLeft(node.right);
        } else {
          break;
        }
      }
    }
  }, {
    key: 'rotateNodeLeft',
    value: function rotateNodeLeft(pivot) {
      var root = pivot.parent;

      if (root.parent) {
        if (root === root.parent.left) {
          root.parent.left = pivot;
        } else {
          root.parent.right = pivot;
        }
      } else {
        this.root = pivot;
      }
      pivot.parent = root.parent;

      root.right = pivot.left;
      if (root.right) {
        root.right.parent = root;
      }

      pivot.left = root;
      pivot.left.parent = pivot;

      root.computeSubtreeProperties();
      pivot.computeSubtreeProperties();
    }
  }, {
    key: 'rotateNodeRight',
    value: function rotateNodeRight(pivot) {
      var root = pivot.parent;

      if (root.parent) {
        if (root === root.parent.left) {
          root.parent.left = pivot;
        } else {
          root.parent.right = pivot;
        }
      } else {
        this.root = pivot;
      }
      pivot.parent = root.parent;

      root.left = pivot.right;
      if (root.left) {
        root.left.parent = root;
      }

      pivot.right = root;
      pivot.right.parent = pivot;

      root.computeSubtreeProperties();
      pivot.computeSubtreeProperties();
    }
  }, {
    key: 'treeFromLineLengths',
    value: function treeFromLineLengths(lineLengths) {
      var start = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
      var end = arguments.length <= 2 || arguments[2] === undefined ? lineLengths.length : arguments[2];
      var parentPriority = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
      return (function () {
        if (start === end) return;

        var priority = this.generateRandom(parentPriority);
        var row = Math.floor((start + end) / 2);
        var left = this.treeFromLineLengths(lineLengths, start, row, priority);
        var right = this.treeFromLineLengths(lineLengths, row + 1, end, priority);
        var node = new _node2['default'](lineLengths[row], left, right, priority);
        if (left) left.parent = node;
        if (right) right.parent = node;

        return node;
      }).apply(this, arguments);
    }
  }, {
    key: 'generateRandom',
    value: function generateRandom() {
      var floor = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

      return this.randomGenerator.floatBetween(floor, 1);
    }
  }]);

  return LineLengthIndex;
})();

exports['default'] = LineLengthIndex;
module.exports = exports['default'];